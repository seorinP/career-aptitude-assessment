{"ast":null,"code":"const toString = Object.prototype.toString;\nconst errorToString = Error.prototype.toString;\nconst regExpToString = RegExp.prototype.toString;\nconst symbolToString = typeof Symbol !== 'undefined' ? Symbol.prototype.toString : () => '';\nconst SYMBOL_REGEXP = /^Symbol\\((.*)\\)(.*)$/;\n\nfunction printNumber(val) {\n  if (val != +val) return 'NaN';\n  const isNegativeZero = val === 0 && 1 / val < 0;\n  return isNegativeZero ? '-0' : '' + val;\n}\n\nfunction printSimpleValue(val) {\n  let quoteStrings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (val == null || val === true || val === false) return '' + val;\n  const typeOf = typeof val;\n  if (typeOf === 'number') return printNumber(val);\n  if (typeOf === 'string') return quoteStrings ? `\"${val}\"` : val;\n  if (typeOf === 'function') return '[Function ' + (val.name || 'anonymous') + ']';\n  if (typeOf === 'symbol') return symbolToString.call(val).replace(SYMBOL_REGEXP, 'Symbol($1)');\n  const tag = toString.call(val).slice(8, -1);\n  if (tag === 'Date') return isNaN(val.getTime()) ? '' + val : val.toISOString(val);\n  if (tag === 'Error' || val instanceof Error) return '[' + errorToString.call(val) + ']';\n  if (tag === 'RegExp') return regExpToString.call(val);\n  return null;\n}\n\nmodule.exports = function printValue(value, quoteStrings) {\n  let result = printSimpleValue(value, quoteStrings);\n  if (result !== null) return result;\n  return JSON.stringify(value, function (key, value) {\n    let result = printSimpleValue(this[key], quoteStrings);\n    if (result !== null) return result;\n    return value;\n  }, 2);\n};","map":{"version":3,"sources":["C:/study/elice-career-test-master/elice-career-test-master/node_modules/yup-locales-ko/printValue.js"],"names":["toString","Object","prototype","errorToString","Error","regExpToString","RegExp","symbolToString","Symbol","SYMBOL_REGEXP","printNumber","val","isNegativeZero","printSimpleValue","quoteStrings","typeOf","name","call","replace","tag","slice","isNaN","getTime","toISOString","module","exports","printValue","value","result","JSON","stringify","key"],"mappings":"AACA,MAAMA,QAAQ,GAAGC,MAAM,CAACC,SAAP,CAAiBF,QAAlC;AACA,MAAMG,aAAa,GAAGC,KAAK,CAACF,SAAN,CAAgBF,QAAtC;AACA,MAAMK,cAAc,GAAGC,MAAM,CAACJ,SAAP,CAAiBF,QAAxC;AACA,MAAMO,cAAc,GAClB,OAAOC,MAAP,KAAkB,WAAlB,GAAgCA,MAAM,CAACN,SAAP,CAAiBF,QAAjD,GAA4D,MAAM,EADpE;AAGA,MAAMS,aAAa,GAAG,sBAAtB;;AAEA,SAASC,WAAT,CAAqBC,GAArB,EAA0B;AACxB,MAAIA,GAAG,IAAI,CAACA,GAAZ,EAAiB,OAAO,KAAP;AACjB,QAAMC,cAAc,GAAGD,GAAG,KAAK,CAAR,IAAa,IAAIA,GAAJ,GAAU,CAA9C;AACA,SAAOC,cAAc,GAAG,IAAH,GAAU,KAAKD,GAApC;AACD;;AAED,SAASE,gBAAT,CAA0BF,GAA1B,EAAqD;AAAA,MAAtBG,YAAsB,uEAAP,KAAO;AACnD,MAAIH,GAAG,IAAI,IAAP,IAAeA,GAAG,KAAK,IAAvB,IAA+BA,GAAG,KAAK,KAA3C,EAAkD,OAAO,KAAKA,GAAZ;AAElD,QAAMI,MAAM,GAAG,OAAOJ,GAAtB;AACA,MAAII,MAAM,KAAK,QAAf,EAAyB,OAAOL,WAAW,CAACC,GAAD,CAAlB;AACzB,MAAII,MAAM,KAAK,QAAf,EAAyB,OAAOD,YAAY,GAAI,IAAGH,GAAI,GAAX,GAAgBA,GAAnC;AACzB,MAAII,MAAM,KAAK,UAAf,EACE,OAAO,gBAAgBJ,GAAG,CAACK,IAAJ,IAAY,WAA5B,IAA2C,GAAlD;AACF,MAAID,MAAM,KAAK,QAAf,EACE,OAAOR,cAAc,CAACU,IAAf,CAAoBN,GAApB,EAAyBO,OAAzB,CAAiCT,aAAjC,EAAgD,YAAhD,CAAP;AAEF,QAAMU,GAAG,GAAGnB,QAAQ,CAACiB,IAAT,CAAcN,GAAd,EAAmBS,KAAnB,CAAyB,CAAzB,EAA4B,CAAC,CAA7B,CAAZ;AACA,MAAID,GAAG,KAAK,MAAZ,EACE,OAAOE,KAAK,CAACV,GAAG,CAACW,OAAJ,EAAD,CAAL,GAAuB,KAAKX,GAA5B,GAAkCA,GAAG,CAACY,WAAJ,CAAgBZ,GAAhB,CAAzC;AACF,MAAIQ,GAAG,KAAK,OAAR,IAAmBR,GAAG,YAAYP,KAAtC,EACE,OAAO,MAAMD,aAAa,CAACc,IAAd,CAAmBN,GAAnB,CAAN,GAAgC,GAAvC;AACF,MAAIQ,GAAG,KAAK,QAAZ,EAAsB,OAAOd,cAAc,CAACY,IAAf,CAAoBN,GAApB,CAAP;AAEtB,SAAO,IAAP;AACD;;AAEDa,MAAM,CAACC,OAAP,GAAiB,SAASC,UAAT,CAAoBC,KAApB,EAA2Bb,YAA3B,EAAyC;AACxD,MAAIc,MAAM,GAAGf,gBAAgB,CAACc,KAAD,EAAQb,YAAR,CAA7B;AACA,MAAIc,MAAM,KAAK,IAAf,EAAqB,OAAOA,MAAP;AAErB,SAAOC,IAAI,CAACC,SAAL,CACLH,KADK,EAEL,UAAUI,GAAV,EAAeJ,KAAf,EAAsB;AACpB,QAAIC,MAAM,GAAGf,gBAAgB,CAAC,KAAKkB,GAAL,CAAD,EAAYjB,YAAZ,CAA7B;AACA,QAAIc,MAAM,KAAK,IAAf,EAAqB,OAAOA,MAAP;AACrB,WAAOD,KAAP;AACD,GANI,EAOL,CAPK,CAAP;AASD,CAbD","sourcesContent":["\nconst toString = Object.prototype.toString\nconst errorToString = Error.prototype.toString\nconst regExpToString = RegExp.prototype.toString\nconst symbolToString =\n  typeof Symbol !== 'undefined' ? Symbol.prototype.toString : () => ''\n\nconst SYMBOL_REGEXP = /^Symbol\\((.*)\\)(.*)$/\n\nfunction printNumber(val) {\n  if (val != +val) return 'NaN'\n  const isNegativeZero = val === 0 && 1 / val < 0\n  return isNegativeZero ? '-0' : '' + val\n}\n\nfunction printSimpleValue(val, quoteStrings = false) {\n  if (val == null || val === true || val === false) return '' + val\n\n  const typeOf = typeof val\n  if (typeOf === 'number') return printNumber(val)\n  if (typeOf === 'string') return quoteStrings ? `\"${val}\"` : val\n  if (typeOf === 'function')\n    return '[Function ' + (val.name || 'anonymous') + ']'\n  if (typeOf === 'symbol')\n    return symbolToString.call(val).replace(SYMBOL_REGEXP, 'Symbol($1)')\n\n  const tag = toString.call(val).slice(8, -1)\n  if (tag === 'Date')\n    return isNaN(val.getTime()) ? '' + val : val.toISOString(val)\n  if (tag === 'Error' || val instanceof Error)\n    return '[' + errorToString.call(val) + ']'\n  if (tag === 'RegExp') return regExpToString.call(val)\n\n  return null\n}\n\nmodule.exports = function printValue(value, quoteStrings) {\n  let result = printSimpleValue(value, quoteStrings)\n  if (result !== null) return result\n\n  return JSON.stringify(\n    value,\n    function (key, value) {\n      let result = printSimpleValue(this[key], quoteStrings)\n      if (result !== null) return result\n      return value\n    },\n    2,\n  )\n}"]},"metadata":{},"sourceType":"script"}